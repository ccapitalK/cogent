--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

-- Potential suggestions:
-- anonymous fields
-- free object recursively
-- tags that has to be previous fields
-- deserialise error offset and array index

include <gum/common/wordarray.cogent>
include <gum/common/array.cogent>
include <gum/common/buffer.cogent>
include <gum/common/crc32.cogent>
include <gum/kernel/linux/errno.cogent>
include "../src/ubi.cogent"

bilbyFsMagic : U32
bilbyFsMagic = 0x0b17b9f5

bilbyFsXinfoMask : U64
bilbyFsXinfoMask = 0x1fffffff

bilbyFsXinfoShift : U64
bilbyFsXinfoShift = 29

inum_from_obj_id : ObjId -> VfsIno
inum_from_obj_id oid = u64_to_u32(oid >> 32)

bilbyFsObjTypeInode : U8
bilbyFsObjTypeInode = 0

bilbyFsObjTypeData : U8
bilbyFsObjTypeData = 1

bilbyFsObjTypeDentarr : U8
bilbyFsObjTypeDentarr = 2

bilbyFsObjTypeDel : U8
bilbyFsObjTypeDel = 3

bilbyFsObjTypeSuper : U8
bilbyFsObjTypeSuper = 4

bilbyFsObjTypePad : U8
bilbyFsObjTypePad = 5

bilbyFsObjTypeSum : U8
bilbyFsObjTypeSum = 6

bilbyFsOidMaskDentarr : U64
bilbyFsOidMaskDentarr = upcast bilbyFsObjTypeDentarr << bilbyFsXinfoShift

bilbyFsOidMaskData : U64
bilbyFsOidMaskData = upcast bilbyFsObjTypeData << bilbyFsXinfoShift

bilbyFsOidMaskInode : U64
bilbyFsOidMaskInode = upcast bilbyFsObjTypeInode << bilbyFsXinfoShift

bilbyFsOidMaskDel : U64
bilbyFsOidMaskDel = upcast bilbyFsObjTypeDel << bilbyFsXinfoShift

bilbyFsOidMaskPad : U64
bilbyFsOidMaskPad = upcast bilbyFsObjTypePad << bilbyFsXinfoShift

bilbyFsOidMaskSum : U64
bilbyFsOidMaskSum = upcast bilbyFsObjTypeSum << bilbyFsXinfoShift

bilbyFsOidMaskAll : U64
bilbyFsOidMaskAll = 7 << bilbyFsXinfoShift

-- TODO rename mk_* instead 
{-# cinline obj_id_dentarr_mk #-}
obj_id_dentarr_mk: (VfsIno, (WordArray U8)!) -> ObjId
obj_id_dentarr_mk (ino, name) =
  let oid:ObjId = upcast ino << 32
  and h = upcast (obj_id_hash_name name)
  in oid .|. bilbyFsOidMaskDentarr .|. h

{-# cinline obj_id_inode_mk #-}
obj_id_inode_mk: VfsIno -> ObjId
obj_id_inode_mk ino =
  (upcast ino << 32) .|. bilbyFsOidMaskInode

{-# cinline obj_id_data_mk #-}
obj_id_data_mk: (VfsIno, U32) -> ObjId
obj_id_data_mk(ino, blk) =
   obj_id_inode_mk ino .|. bilbyFsOidMaskData .|. upcast blk

{-# cinline obj_id_pad_mk #-}
obj_id_pad_mk: () -> ObjId
obj_id_pad_mk _ = bilbyFsOidMaskPad

{-# cinline obj_id_type #-}
obj_id_type: ObjId -> U64
obj_id_type oid = 
   ((oid .&. bilbyFsOidMaskAll) >> bilbyFsXinfoShift)

obj_id_hash_map: #{elem: U8, acc: U32, obsv: ()} -> LoopResult U32 U32
obj_id_hash_map #{elem, acc=a, obsv} = 
  let v = upcast elem
  and a = a + v << 4
  and a = a + v >> 4
  in Iterate (a * 11)

obj_id_hash_name: (WordArray U8)! -> U32
obj_id_hash_name nm =
  let a:U32 = 0
  and len = wordarray_length[U8] nm
  in wordarray_fold[U8, U32, (), U32] #{arr=nm, frm=0, to=len, f=obj_id_hash_map, acc=a, obsv=()}
  | Break a -> cogent_assert False ; a .&. (u64_to_u32 bilbyFsXinfoMask)
  | Iterate a -> a .&. (u64_to_u32 bilbyFsXinfoMask)

{-# cinline obj_id_end_mk #-}
obj_id_end_mk: VfsIno -> ObjId
obj_id_end_mk ino =
   obj_id_inode_mk ino .|. upcast word32Max

{-# cinline obj_id_is_inode #-}
obj_id_is_inode: ObjId -> Bool
obj_id_is_inode oid =
   obj_id_type oid == upcast bilbyFsObjTypeInode

{-# cinline obj_id_is_dentarr #-}
obj_id_is_dentarr: ObjId -> Bool
obj_id_is_dentarr oid =
   obj_id_type oid == upcast bilbyFsObjTypeDentarr

{-# cinline obj_id_is_data #-}
obj_id_is_data: ObjId -> Bool
obj_id_is_data oid =
   obj_id_type oid == upcast bilbyFsObjTypeData

type Obj = {
       magic : U32,
       crc : U32,
       sqnum : U64,
       offs : U32, -- in-mem only field
       len : U32,
      -- , pad1 : U8
      -- , pad2 : U8
       trans : ObjTrans,
       otype : ObjType,
       ounion : ObjUnion
}

bilbyFsObjHeaderSize : U32
bilbyFsObjHeaderSize = 24

serialise_ObjHeader:(Buffer, BufOffs, Obj!) -> (Buffer, BufOffs)
serialise_ObjHeader(buf, offs, obj) =
  let buf = serialise_le32(buf, offs, obj.magic)
  and buf = serialise_le32(buf, offs+4, obj.crc)
  and buf = serialise_le64(buf, offs+8, obj.sqnum)
  and buf = serialise_le32(buf, offs+16, obj.len)
  and buf = serialise_u8(buf, offs+20, bilbyFsPadByte)
  and buf = serialise_u8(buf, offs+21, bilbyFsPadByte)
  and buf = serialise_u8(buf, offs+22, obj.trans)
  and buf = serialise_u8(buf, offs+23, obj.otype)
  in (buf, offs + bilbyFsObjHeaderSize)

print_ObjHeader:(Obj take (ounion))! -> ()
#if DEBUG
print_ObjHeader obj =
  cogent_debug "ObjHeader = {magic=" ;
  cogent_debug_u32_hex obj.magic ;
  cogent_debug ",crc=" ;
  cogent_debug_u32_hex(obj.crc) ;
  cogent_debug ",sqnum=" ;
  cogent_debug_u64_hex(obj.sqnum) ;
  cogent_debug ",len=" ;
  cogent_debug_u32(obj.len) ;
  cogent_debug ",offs=" ;
  cogent_debug_u32(obj.offs) ;
  cogent_debug ",pad=" ;
  cogent_debug_u8(bilbyFsPadByte) ;
  cogent_debug ",pad=" ;
  cogent_debug_u8(bilbyFsPadByte) ;
  cogent_debug ",trans=" ;
  cogent_debug_u8(obj.trans) ;
  cogent_debug ",otype=" ;
  cogent_debug_u8(obj.otype) ;
  cogent_debug "}\n"
#else
print_ObjHeader _ = ()
#endif

print_ObjSuper:ObjSuper! -> ()
#if DEBUG
print_ObjSuper obj =
  cogent_debug "ObjSuper = {nb_eb=" ;
  cogent_debug_u32 obj.nb_eb ;
  cogent_debug ",eb_size=" ;
  cogent_debug_u32(obj.eb_size) ;
  cogent_debug ",io_size=" ;
  cogent_debug_u32(obj.io_size) ;
  cogent_debug ",nb_reserved_gc=" ;
  cogent_debug_u32(obj.nb_reserved_gc) ;
  cogent_debug ",nb_reserved_del=" ;
  cogent_debug_u32(obj.nb_reserved_del) ;
  cogent_debug ",cur_eb=" ;
  cogent_debug_u32(obj.cur_eb) ;
  cogent_debug ",cur_offs=" ;
  cogent_debug_u32(obj.cur_offs) ;
  cogent_debug ",last_inum=" ;
  cogent_debug_u32(obj.last_inum) ;
  cogent_debug ",next_sqnum=" ;
  cogent_debug_u64(obj.next_sqnum) ;
  cogent_debug "}\n"
#else
print_ObjSuper _ = ()
#endif

print_ObjDentry:ObjDentry! -> ()
#if DEBUG
print_ObjDentry obj =
  cogent_debug "ObjDentry = {ino=" ;
  cogent_debug_u32 obj.ino ;
  cogent_debug ",dtype=" ;
  cogent_debug_u8(obj.dtype) ;
  cogent_debug ",nlen=" ;
  cogent_debug_u16(obj.nlen) ;
  cogent_debug ",name=(not displayed)" ;
  cogent_debug "}\n"
#else
print_ObjDentry _ = ()
#endif

{-# cinline serialise_Obj #-}
serialise_Obj:(Buffer, BufOffs, Obj!) -> (Buffer, BufOffs)
serialise_Obj(buf, offs, obj) =
  let (buf, offs) = serialise_ObjHeader(buf, offs, obj)
  in serialise_ObjUnion(buf, offs, obj.ounion, obj.len)

deserialise_ObjUnion: (SysState, Buffer!, U32, (ObjType, U32)) -> R (SysState, ObjUnion, U32) (ErrCode, SysState)
deserialise_ObjUnion(ex, buf, offs, (otype, olen)) =
  if otype == bilbyFsObjTypeInode then
    deserialise_ObjInode(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjInode obj, offs)
  else if otype == bilbyFsObjTypeData then
    deserialise_ObjData(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjData obj, offs)
  else if otype == bilbyFsObjTypeDentarr then
    deserialise_ObjDentarr(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjDentarr obj, offs)
  else if otype == bilbyFsObjTypeDel then
    deserialise_ObjDel(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjDel obj, offs)
  else if otype == bilbyFsObjTypeSuper then
    deserialise_ObjSuper(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjSuper obj, offs)
  -- if otype == bilbyFsObjTypeSummary, we return an padding object,
  -- we should NOT call this deserialisation function for summaries.
  -- Main reason for this exception is avoid allocation of gigantic
  -- summaries.
  else -- if otype == bilbyFsObjTypePad then
    deserialise_ObjPad(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, obj, offs) ->
      Success (ex, TObjPad obj, offs)

is_len_and_type_ok: (U8, U32) -> Bool
is_len_and_type_ok(otype, olen) =
  if otype == bilbyFsObjTypeInode then
    olen == bilbyFsObjHeaderSize + bilbyFsObjInode
  else if otype == bilbyFsObjTypeData then
    olen >= bilbyFsObjHeaderSize + bilbyFsObjDataHeaderSize
  else if otype == bilbyFsObjTypeDentarr then
    -- dentarr on-flash must have 1 entry minimum
    olen >= bilbyFsObjHeaderSize + bilbyFsObjDentarrHeaderSize + bilbyFsObjDentryHeaderSize
  else if otype == bilbyFsObjTypeDel then
    olen == bilbyFsObjHeaderSize + bilbyFsObjDelSize
  else if otype == bilbyFsObjTypeSuper then
    olen == bilbyFsObjHeaderSize + bilbyFsObjSuperSize
  else if otype == bilbyFsObjTypeSum then
    olen >= bilbyFsObjHeaderSize + bilbyFsObjSummaryHeaderSize
  else if otype == bilbyFsObjTypePad then
    olen >= bilbyFsObjHeaderSize
  else
    False

deserialise_ObjHeader: (Buffer!, BufOffs, Obj take (..)) -> RR (Obj take (ounion)) BufOffs ErrCode
deserialise_ObjHeader (buf, offs, obj) =
  let magic = deserialise_le32(buf, offs)
  and crc = deserialise_le32(buf, offs+4)
  and sqnum = deserialise_le64(buf, offs+8)
  and len = deserialise_le32(buf, offs+16)
  -- skip 2 pad bytes
  and trans = deserialise_u8(buf, offs+22)
  and otype = deserialise_u8(buf, offs+23)
  and obj = obj {magic,crc,sqnum,offs,len,trans,otype}
  and end_offs = len + offs
  in if end_offs < offs || end_offs > buf.bound ||
        magic /= bilbyFsMagic ||
        (trans /= bilbyFsTransIn && trans /= bilbyFsTransCommit) ||
        not (is_len_and_type_ok(otype, len))
  then
    (obj, Error eInval)
  else
    (obj, Success (offs + bilbyFsObjHeaderSize))

deserialise_Obj: (SysState, Buffer!, BufOffs) -> R (SysState, Obj, BufOffs) (ErrCode, SysState)
deserialise_Obj(ex, buf, offs) =
  let Success (ex, obj) <= newObj ex |> Error ex -> Error (eNoMem, ex)
  and (obj, r) = deserialise_ObjHeader (buf, offs, obj)
  and Success offs <= r |> Error e -> let ex = freeObj (ex, obj) in Error (e, ex)
   in deserialise_ObjUnion(ex, buf, offs, (obj.otype,obj.len)) !obj
      | Error (e, ex) ->
        let ex = freeObj (ex, obj)
        in Error (e, ex)
      | Success (ex, ounion, offs') ->
        let obj = obj {ounion}
        in Success (ex, obj, offs')

newObj: SysState -> R (SysState, Obj take(..)) SysState
freeObj: (SysState, Obj take(..)) -> SysState

{-# cinline deep_freeObj #-}
deep_freeObj: (SysState, Obj) -> SysState
deep_freeObj(ex, obj) =
  let obj {magic, crc, sqnum, offs, len, trans, otype, ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  in freeObj(ex, obj)

type ObjUnion = <TObjDentarr ObjDentarr
  | TObjInode ObjInode
  | TObjData ObjData
  | TObjDel ObjDel
  | TObjSuper ObjSuper
  | TObjSummary ObjSummary
  | TObjPad ()>

{-# cinline serialise_ObjPad #-}
serialise_ObjPad: (Buffer,  BufOffs, U32) -> (Buffer, BufOffs)
serialise_ObjPad(buf, offs, olen) =
 let padlen = olen - bilbyFsObjHeaderSize
 and buf = buf_memset(buf, offs, padlen, bilbyFsPadByte)
 in (buf, offs + padlen)

{-# cinline deserialise_ObjPad #-}
deserialise_ObjPad: (SysState, Buffer!, BufOffs, U32) -> R (SysState, (), BufOffs) (ErrCode, SysState)
deserialise_ObjPad(ex, buf, offs, olen) =
  let len = olen - bilbyFsObjHeaderSize
  in if len > olen then
    Error (eInval, ex)
  else
    Success (ex, (), offs + len)

serialise_ObjUnion:(Buffer, BufOffs, ObjUnion!, U32) -> (Buffer, BufOffs)
serialise_ObjUnion(buf, offs, ou, olen) =
  ou
  | TObjDentarr obj -> serialise_ObjDentarr(buf, offs, obj)
  | TObjInode obj -> serialise_ObjInode(buf, offs, obj)
  | TObjData obj -> serialise_ObjData(buf, offs, obj, olen)
  | TObjDel obj -> serialise_ObjDel(buf, offs, obj)
  | TObjSuper obj -> serialise_ObjSuper(buf, offs, obj)
  | TObjSummary obj -> serialise_ObjSummary(buf, offs, obj)
  | TObjPad _ -> serialise_ObjPad(buf, offs, olen)

{-# cinline deep_freeObjDentry #-}
deep_freeObjDentry: (SysState, ObjDentry) -> SysState
deep_freeObjDentry(ex, obj {name}) =
  let ex = freeObjDentry(ex, obj)
  in wordarray_free[U8](ex, name)

{-# cinline deep_freeObjDentarr #-}
deep_freeObjDentarr: (SysState, ObjDentarr) -> SysState
deep_freeObjDentarr(ex, obj {id,nb_dentry,entries}) =
  let ex = freeObjDentarr(ex, obj)
  in array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}

{-# cinline deep_freeObjUnion #-}
deep_freeObjUnion: (SysState, ObjUnion) -> SysState
deep_freeObjUnion(ex, ounion) =
 ounion
 | TObjDentarr obj -> deep_freeObjDentarr(ex, obj)
 | TObjInode obj {id,size,atime_sec,ctime_sec,
               mtime_sec,nlink,uid,gid,mode, flags} ->
   freeObjInode(ex, obj)
 | TObjData obj {id,odata} ->
   let ex = freeObjData(ex, obj)
   in wordarray_free[U8](ex, odata)
 | TObjDel obj {id} -> ex
 | TObjSuper obj {nb_eb,eb_size,io_size,cur_eb,cur_offs,next_sqnum,
               last_inum, nb_reserved_gc, nb_reserved_del} ->
   freeObjSuper(ex, obj)
 | TObjSummary obj {nb_sum_entry,entries,sum_offs} ->
   let ex = wordarray_free[ObjSumEntry](ex, entries)
   in freeObjSummary(ex, obj)
 | TObjPad _ -> ex

type ObjType = U8
type ObjTrans = U8
type ObjId = U64
type ObjIdDentarr = U64
type ObjIdData = U64
type ObjIdInode = U64

bilbyFsObjDelSize: U32
bilbyFsObjDelSize = 8

type ObjDel = #{ id : ObjId } take ()
{-# cinline serialise_ObjDel #-}
serialise_ObjDel:(Buffer, BufOffs, ObjDel!) -> (Buffer, BufOffs)
serialise_ObjDel(buf, offs, od) =
  let buf = serialise_le64(buf, offs, od.id)
  in (buf, offs + bilbyFsObjDelSize)

{-# cinline serialise_size_ObjDel #-}
serialise_size_ObjDel: ObjDel! -> U32
serialise_size_ObjDel _ = bilbyFsObjDelSize

deserialise_ObjDel: (SysState, Buffer!, BufOffs) -> R (SysState, ObjDel, BufOffs) (ErrCode, SysState)
deserialise_ObjDel(ex, buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- Ensure type of oid is ObjData
  and idtype = id .&. binNot bilbyFsOidMaskAll
  in if idtype /= bilbyFsOidMaskData && 
        idtype /= bilbyFsOidMaskInode &&
        idtype /= bilbyFsOidMaskDentarr then
      Error (eInval, ex)
    else
      Success (ex, #{id}, offs + 8)

bilbyFsItypeReg: U8
bilbyFsItypeReg = 0

bilbyFsItypeDir: U8
bilbyFsItypeDir = 1

bilbyFsItypeLnk: U8
bilbyFsItypeLnk = 2

bilbyFsItypeBlk: U8
bilbyFsItypeBlk = 3

bilbyFsItypeChr: U8
bilbyFsItypeChr = 4

bilbyFsItypeFifo: U8
bilbyFsItypeFifo = 5

bilbyFsItypeSock: U8
bilbyFsItypeSock = 6

type ObjDentry = {
  ino : U32,
  dtype : U8,
  -- pad : U8,
  nlen : U16,
  name : WordArray U8
}

bilbyFsObjDentryHeaderSize:U32
bilbyFsObjDentryHeaderSize = 8
{-
  definition "PObjDentry data offs ==
      let nlen = Ple16 data (offs+6) (* includes \0 *)
      in ObjDentry.make
         (Ple32 data offs) (* ino *)
         (Pu8 data (offs+4)) (* dtype *)
         nlen
         (Pwordarray_u8 data (offs+8) nlen) (* len *)
         (* end 8 + nlen bytes *)"

  precond:
    dentry.nlen = u32_to_u16 (wordarray_length[U8] dentry.name)
    offs + 8 + wordarray_length[U8] dentry.name <= buf.bound
  postcond:
   r = serialise_ObjDentry(buf, offs, dentry) /\
   PObjDentry (fst r) offs = dentry /\ snd r = offs + 8 + nlen
-}
serialise_ObjDentry:(Buffer, BufOffs, ObjDentry!) -> (Buffer, BufOffs)
serialise_ObjDentry(buf, offs, dentry) =
  print_ObjDentry dentry ;
  let buf = serialise_le32(buf, offs, dentry.ino)
  and buf = serialise_u8(buf, offs+4, dentry.dtype)
  and buf = serialise_u8(buf, offs+5, bilbyFsPadByte)
  and buf = serialise_le16(buf, offs+6, dentry.nlen)
  and buf = serialise_wordarray_U8(buf, offs+8, dentry.name)
  in (buf, offs + bilbyFsObjDentryHeaderSize + wordarray_length[U8] dentry.name)

{-# cinline serialise_size_ObjDentry #-}
serialise_size_ObjDentry: ObjDentry! -> U32
serialise_size_ObjDentry dent = bilbyFsObjDentryHeaderSize + wordarray_length[U8] dent.name

{-
  precond:
    dentry.nlen = u32_to_u16 (wordarray_length[U8] dentry.name)
    dentry.nlen < 256
    offs + 8 + u16_to_u32 (Ple16 data (offs+6)) <= buf.bound
  postcond:
!!h e.
  let nlen32 = u16_to_u32 (Ple16 data (offs+6))
  in if offs + 8 + nlen32 <= buf.bound then
    Error (fst(select(h,{eNoMem,eInval})), h)
  else
    Success (h, PObjDentry buf.data offs, offs + 8 + nlen32)
-}
deserialise_ObjDentry: (SysState, Buffer!, BufOffs, U32) -> R (SysState, ObjDentry, BufOffs) (ErrCode, SysState)
deserialise_ObjDentry(ex, buf, offs, end_offs) =
  let ino = deserialise_le32(buf, offs)
  and dtype = deserialise_u8(buf, offs+4)
  and nlen = deserialise_le16(buf, offs+6)

 -- There is a constrain on nlen to check that it is within the buffer bound.
 -- This has to be checked as we deserialise because nlen
 -- is read from the buffer (as opposed to bound checks
 -- encoded in the preconditions
  and nlen32 = upcast nlen 
  in if offs + bilbyFsObjDentryHeaderSize + nlen32 > buf.bound ||
        nlen32 > bilbyFsMaxNameLen + 1 ||
        nlen32 == 0 ||
        offs + bilbyFsObjDentryHeaderSize + nlen32 > end_offs
         then
    Error (eInval, ex)
  else
    -- deserialise_wordarray_U8 guarantees that: length name = nlen
    let Success (ex, name) <= deserialise_wordarray_U8(ex, buf, offs + bilbyFsObjDentryHeaderSize, nlen32)
          |> Error (e, ex) -> 
                              Error (e, ex)
    and Success (ex, dentry) <= newObjDentry ex
          |> Error ex -> let ex = wordarray_free[U8](ex, name)
                          in Error (eNoMem, ex)
    and dentry = dentry {ino, dtype, nlen, name}
     in Success (ex, dentry, offs + bilbyFsObjDentryHeaderSize + nlen32)

newObjDentry: SysState -> R (SysState, ObjDentry take(..)) SysState
freeObjDentry: (SysState, ObjDentry take (..)) -> SysState

type ObjDentarr = {
  id : ObjId,
  nb_dentry : U32,
  entries : Array ObjDentry
}
newObjDentarr: SysState -> R (SysState, ObjDentarr take(..)) SysState
freeObjDentarr: (SysState, ObjDentarr take (..)) -> SysState

{-# cinline serialise_Arr_ObjDentry_f #-}
serialise_Arr_ObjDentry_f: #{elem:ObjDentry!, acc:(Buffer, BufOffs), obsv:()} -> (Buffer, BufOffs)
serialise_Arr_ObjDentry_f #{elem=dentry,acc=(buf,offs), obsv=()} =
  serialise_ObjDentry(buf, offs, dentry)

{-# cinline serialise_Array_ObjDentry #-}
serialise_Array_ObjDentry: (Buffer, BufOffs, (Array ObjDentry)!) -> (Buffer, BufOffs)
serialise_Array_ObjDentry(buf, offs, arr) =
  array_fold_no_break[ObjDentry, (Buffer, BufOffs), ()]
    #{arr, f=serialise_Arr_ObjDentry_f, acc=(buf, offs), obsv=()}

bilbyFsObjDentarrHeaderSize: U32
bilbyFsObjDentarrHeaderSize = 12

serialise_ObjDentarr:(Buffer, BufOffs, ObjDentarr!) -> (Buffer, BufOffs)
serialise_ObjDentarr(buf, offs, dentarr) =
  let buf = serialise_le64(buf, offs, dentarr.id)
  and buf = serialise_le32(buf, offs+8, dentarr.nb_dentry)
  in serialise_Array_ObjDentry(buf, offs+bilbyFsObjDentarrHeaderSize, dentarr.entries)

{-# cinline serialise_size_Arr_ObjDentry_f #-}
serialise_size_Arr_ObjDentry_f: #{elem:ObjDentry!, acc:U32, obsv:()} -> U32
serialise_size_Arr_ObjDentry_f #{elem=dentry,acc=sz, obsv=()} =
  sz + serialise_size_ObjDentry(dentry)

{-# cinline serialise_size_Array_ObjDentry #-}
serialise_size_Array_ObjDentry: (Array ObjDentry)! -> U32
serialise_size_Array_ObjDentry arr =
  array_fold_no_break[ObjDentry, U32, ()] #{arr, f=serialise_size_Arr_ObjDentry_f, acc=0, obsv=()}

{-# cinline serialise_size_ObjDentarr #-}
serialise_size_ObjDentarr: ObjDentarr! -> U32
serialise_size_ObjDentarr dentarr = bilbyFsObjDentarrHeaderSize + serialise_size_Array_ObjDentry dentarr.entries

{-# cinline deep_freeOptionObjDentry #-}
deep_freeOptionObjDentry: (SysState, Option ObjDentry) -> SysState
deep_freeOptionObjDentry (ex, opt_dent) =
  opt_dent | None -> ex
           | Some obj -> deep_freeObjDentry(ex, obj)

-- #{oelem:Option ObjDentry, acc: (SysState, U32), obsv: Buffer!} -> LoopResult (Option ObjDentry, (SysState, U32)) (Option ObjDentry, (ErrCode, SysState))
loop_deserialise_ObjDentry: ArrayMapF ObjDentry (SysState, U32) (Buffer!,U32) (ErrCode, SysState)
loop_deserialise_ObjDentry #{oelem, acc=(ex,offs), obsv=(buf,end_offs)} =
  let ex = deep_freeOptionObjDentry(ex, oelem) 
  in deserialise_ObjDentry(ex, buf, offs, end_offs)
  | Error (err, ex) ->
    Break (None, (eInval, ex))
  | Success (ex, dent, offs) ->
    Iterate (Some dent, (ex, offs))

deserialise_Array_ObjDentry: (SysState, Buffer!, BufOffs, U32, U32) -> R (SysState, Array ObjDentry, BufOffs) (ErrCode, SysState)
deserialise_Array_ObjDentry(ex, buf, offs, nb_dentry, end_offs) =
  -- we always allocate an extra slot for potentially adding an entry
  array_create[ObjDentry] (ex, nb_dentry + 1)
  | Error ex ->
    Error (eNoMem, ex)
  | Success (ex, arr) ->
    array_map[ObjDentry, (SysState, U32), (Buffer!,U32), (ErrCode, SysState)]
      #{arr, frm=0, to=nb_dentry, f=loop_deserialise_ObjDentry, acc=(ex, offs), obsv=(buf,end_offs)}
    | Break (arr, (err, ex)) ->
      let ex = array_free[ObjDentry] #{arr, f=deep_freeObjDentry, ex}
      in Error (err, ex)
    | Iterate (arr, (ex, offs)) ->
      Success (ex, arr, offs)

deserialise_ObjDentarr: (SysState, Buffer!, BufOffs, U32) -> R (SysState, ObjDentarr, BufOffs) (ErrCode, SysState) 
deserialise_ObjDentarr(ex, buf, offs, olen) =
  let id = deserialise_le64(buf, offs)
  and nb_dentry = deserialise_le32(buf, offs+8)
  in deserialise_Array_ObjDentry(ex, buf, offs+bilbyFsObjDentarrHeaderSize, nb_dentry, offs+olen-bilbyFsObjHeaderSize)
  | Error (e,ex) ->
    Error (e, ex)
  | Success (ex, entries, offs) ->
    newObjDentarr ex
    | Error ex ->
      let ex = array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}
      in Error (eNoMem, ex)
    | Success (ex, dentarr) ->
      let dentarr = dentarr {id,nb_dentry,entries}
      in Success (ex, dentarr, offs)

bilbyFsSumEntryDelFlagMask: U32
bilbyFsSumEntryDelFlagMask = 0x80000000

type ObjSumEntry = #{
  id : U64,
  sqnum : U64,
  len : U32,
  del_flags_and_offs : U32,
  count : U16 -- nb of object covered by the deletion object
}

obj_sum_entry_offs: ObjSumEntry -> U32
obj_sum_entry_offs entry =
  entry.del_flags_and_offs .&. (complement bilbyFsSumEntryDelFlagMask)

obj_sum_entry_is_del: ObjSumEntry -> Bool
obj_sum_entry_is_del entry = 
  (entry.del_flags_and_offs .&. bilbyFsSumEntryDelFlagMask) /= 0


bilbyFsObjSumEntrySize : U32
bilbyFsObjSumEntrySize = 26

type ObjSummary = {
  nb_sum_entry : U32, -- nb_sum_entry must be <= wordarray_length sum.entries
                   -- the wordarray is ususally larger than what's get serialised.
                   -- Using an array for this would be too inefficient.
  entries : WordArray ObjSumEntry, -- only @nb_sum_entry element get serialised on medium
  -- At the very end of the summary is the offset of the summary itself.
  sum_offs : U32
}
bilbyFsObjSummaryHeaderSize: U32
bilbyFsObjSummaryHeaderSize = 4

bilbyFsObjSummaryOffsSize: U32
bilbyFsObjSummaryOffsSize = 4

newObjSummary: SysState -> R (SysState, ObjSummary take(..)) SysState
freeObjSummary: (SysState, ObjSummary take (..)) -> SysState

summary_init: (SysState, U32) -> R (SysState, ObjSummary, Obj) SysState
summary_init(ex, max_nb_sum_entry) =
  let Success (ex, sum) <= newObjSummary ex |> Error ex -> Error ex
  and Success (ex, entries) <= wordarray_create[ObjSumEntry] (ex, max_nb_sum_entry)
      |> Error ex ->
           let ex = freeObjSummary (ex, sum)
           in Error ex
  and Success (ex, sum_obj) <= newObj ex
      |> Error ex ->
           let ex = freeObjSummary (ex, sum)
           and ex = wordarray_free[ObjSumEntry] (ex, entries)
           in Error ex
  and sum_obj = obj_init_default (sum_obj, bilbyFsObjTypeSum) 
  and sum_obj = sum_obj {trans=bilbyFsTransCommit, ounion = TObjPad ()}
  and sum_offs:U32 = 0
  in Success (ex, sum {nb_sum_entry=0, entries, sum_offs}, sum_obj)

summary_clean: (SysState, ObjSummary) -> SysState
summary_clean(ex, sum {entries}) =
  let ex = wordarray_free[ObjSumEntry] (ex, entries)
  in freeObjSummary(ex, sum)

serialise_ObjSummary:(Buffer, BufOffs, ObjSummary!) -> (Buffer, BufOffs)
serialise_ObjSummary(buf, offs, sum) =
  -- cogent_assert(offs == sum.sum_offs) ;
  let buf = serialise_le32(buf, offs, sum.nb_sum_entry)
  and (buf, offs) = serialise_wordarray_ObjSumEntry(buf, offs+4, sum.entries, sum.nb_sum_entry)
  and buf = serialise_le32(buf, offs, sum.sum_offs)
  in (buf, offs + 4)

serialise_ObjSummary_crc:(Buffer, BufOffs, Obj, ObjSummary!) -> (Obj, Buffer, BufOffs)
serialise_ObjSummary_crc(buf, offs, sum_obj, sum) =
  let (buf, offs') = serialise_ObjHeader(buf, offs, sum_obj) !sum_obj
  and (buf, offs') = serialise_ObjSummary(buf, offs', sum)
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf #{buf, frm=offs + 8, to=offs'} !buf
  and sum_obj = sum_obj {crc}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (sum_obj, buf, offs')

{-# inline serialise_ObjSumEntry_f #-}
serialise_ObjSumEntry_f: #{elem:ObjSumEntry!, acc:(Buffer, BufOffs),  obsv:()} -> (Buffer, BufOffs)
serialise_ObjSumEntry_f #{elem=sumentry, acc=(buf,offs) , obsv} = 
  serialise_ObjSumEntry(buf, offs, sumentry)

serialise_ObjSumEntry:(Buffer, BufOffs, ObjSumEntry!) -> (Buffer, BufOffs)
serialise_ObjSumEntry(buf, offs, sumentry) =
  let buf = serialise_le64(buf, offs, sumentry.id)
  and buf = serialise_le64(buf, offs+8, sumentry.sqnum)
  and buf = serialise_le32(buf, offs+16, sumentry.len)
  and buf = serialise_le32(buf, offs+20, sumentry.del_flags_and_offs)
  and buf = serialise_le16(buf, offs+24, sumentry.count)
  in (buf, offs + bilbyFsObjSumEntrySize)

serialise_wordarray_ObjSumEntry: (Buffer, BufOffs, (WordArray ObjSumEntry)!, U32) -> (Buffer, BufOffs)
serialise_wordarray_ObjSumEntry(buf, offs, entries, nb_sum_entry) =
  let arrsz = bilbyFsObjSumEntrySize * nb_sum_entry 
  and end = if offs + arrsz > buf.bound then buf.bound else offs + arrsz !buf
  -- return partially serialised array if the bound is too small.
   in wordarray_fold_no_break[ObjSumEntry, (Buffer, BufOffs), ()]
        #{arr=entries, frm=0, to=nb_sum_entry, f=serialise_ObjSumEntry_f, acc=(buf, offs), obsv=()}

{-# cinline serialise_size_ObjSummary #-}
serialise_size_ObjSummary: U32 -> U32
serialise_size_ObjSummary nb_sum_entry =
  bilbyFsObjSummaryHeaderSize + nb_sum_entry * bilbyFsObjSumEntrySize + bilbyFsObjSummaryOffsSize

-- Size of the total object (including ObjHeader)
serialise_size_summary_Obj_with_extra: (ObjSummary!, U32) -> U32
serialise_size_summary_Obj_with_extra (summary, nb_extra) =
  bilbyFsObjHeaderSize + serialise_size_ObjSummary (summary.nb_sum_entry + nb_extra)

{-# inline deserialise_ObjSumEntry #-}
deserialise_ObjSumEntry: (Buffer!, BufOffs) -> (ObjSumEntry, BufOffs)
deserialise_ObjSumEntry(buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- check if valid object id
  and sqnum = deserialise_le64(buf, offs+8)
  and len = deserialise_le32(buf, offs+16)
  and del_flags_and_offs = deserialise_le32(buf, offs+20)
  and count = deserialise_le16(buf, offs+24)
  and entry = #{id,sqnum,len,del_flags_and_offs,count}
  in (entry, offs+26)

{-# cinline deserialise_ObjSumEntry_map #-}
deserialise_ObjSumEntry_map: #{elem:ObjSumEntry,acc:BufOffs, obsv:Buffer!} -> (ObjSumEntry, BufOffs)
deserialise_ObjSumEntry_map #{elem=entry, acc=offs, obsv=buf} =
  let (entry, offs) = deserialise_ObjSumEntry(buf, offs)
  in (entry, offs)

-- FIXME: this function looks largely strange -- the wordarray is not used in 
-- the computation at all! / zilinc
deserialise_wordarray_ObjSumEntry: (WordArray ObjSumEntry, Buffer!, BufOffs, U32) -> RR (WordArray ObjSumEntry) BufOffs ErrCode
deserialise_wordarray_ObjSumEntry (entries, buf, offs, nb_sum_entry) =
  let (entries,offs) = wordarray_map_no_break[ObjSumEntry, BufOffs, Buffer!]
                         #{arr=entries, frm=0, to=nb_sum_entry, f=deserialise_ObjSumEntry_map, acc=offs, obsv=buf}
   in (entries, Success offs) 

deserialise_ObjSummary_crc: (SysState, Buffer!, BufOffs, Obj, ObjSummary) -> RR (SysState, Obj, ObjSummary) BufOffs ErrCode
deserialise_ObjSummary_crc (ex, buf, offs, obj, summary) =
  let obj {offs=_, magic, crc, sqnum, len, trans, otype, ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  and (obj, r) = deserialise_ObjHeader(buf, offs, obj)
  and Success offs' <= r
      |> Error e -> ((ex, obj {ounion =TObjPad ()}, summary), Error e)
  and (summary, r) = deserialise_ObjSummary(buf, offs', summary)
  and Success offs' <= r |> Error e -> ((ex, obj {ounion =TObjPad ()}, summary), Error e)
  and crcsum = crc32_buf #{buf, frm = offs + 8, to = offs'}
  and crc = obj.crc !obj
  and obj {offs=_} = obj
  and obj = obj {offs}
  and _ = print_ObjHeader obj !obj
  and obj = obj {ounion = TObjPad ()} 
  in if crc == crcsum then
    ((ex, obj, summary), Success offs')
  else
    ((ex, obj, summary), Error eInval)

deserialise_ObjSummary: (Buffer!, BufOffs, ObjSummary) -> RR ObjSummary BufOffs ErrCode
deserialise_ObjSummary(buf, offs, sum {entries}) =
  let nb_sum_entry = deserialise_le32(buf, offs)
  and (entries, r) = deserialise_wordarray_ObjSumEntry(entries, buf, offs + 4, nb_sum_entry)
  and Success offs' <= r |> Error e -> (sum {nb_sum_entry, entries}, Error e)
  and sum_offs = deserialise_le32(buf, offs')
  -- FIXME check that sum_offs == offs
  in (sum {nb_sum_entry, entries, sum_offs}, Success (offs'+4))

type ObjData = #{
  id : ObjId,
  odata : WordArray U8
}

serialise_wordarray_U8: (Buffer, BufOffs, (WordArray U8)!) -> Buffer
serialise_wordarray_U8(buf {data}, offs, wa) =
  let len = wordarray_length[U8] wa
  and end = if offs + len > buf.bound then buf.bound else offs + len !buf

  -- return partially serialised array if the bound is too small.

  and data = wordarray_copy[U8] (data, wa, offs, 0, end)
  in buf {data}

serialise_ObjData:(Buffer, BufOffs, ObjData!, U32) -> (Buffer, BufOffs)
serialise_ObjData(buf, offs, od, olen) =
  let arrlen = olen - bilbyFsObjHeaderSize - 8
  and buf = serialise_le64(buf, offs, od.id)
-- Shrinks the buffer bound to only write the required length
-- so that we can have an ObjData that has an array larger than
-- needed and reuse that array.
  and bound = buf.bound !buf
  and buf = buf {bound = offs + 8 + arrlen}
  and buf = serialise_wordarray_U8(buf, offs+8, od.odata)
  and offs = buf.bound !buf
  and buf = buf {bound}
  in (buf, offs)

bilbyFsObjDataHeaderSize : U32
bilbyFsObjDataHeaderSize = 8

-- NOTE This value is wrong if odata array is larger than it needs to be
serialise_size_ObjData: ObjData! -> U32
serialise_size_ObjData od = bilbyFsObjDataHeaderSize + wordarray_length[U8] od.odata

deserialise_waU8_map: #{elem:U8,acc:BufOffs, obsv:(WordArray U8)!} -> (U8, BufOffs)
deserialise_waU8_map #{elem=_, acc=offs, obsv=data} =
 (wordarray_get[U8](data, offs), offs + 1)
-- We can't make this function polymorphic because we
-- don't have a polymorphic function to deserialise
-- array elements
deserialise_wordarray_U8: (SysState, Buffer!, BufOffs, U32) -> R (SysState, WordArray U8) (ErrCode, SysState)
deserialise_wordarray_U8 (ex, buf, offs, len) =
  wordarray_create[U8] (ex, len)
  | Error ex -> Error (eNoMem, ex) 
  | Success (ex, wa) ->
    let wa = wordarray_copy[U8] (wa, buf.data, 0, offs, len)
    in Success (ex, wa)
  
{-
precondition:
    offs + 8 + len <= buf.bound
postcondition:
  !!h. if is_odata_id (le64 buf.data offs) then
    Error (eInval, h)
  else
    Success (h, PObjData buf.data offs, offs + 8 + len)
-}
deserialise_ObjData: (SysState, Buffer!, BufOffs, U32) -> R (SysState, ObjData, BufOffs) (ErrCode, SysState)
deserialise_ObjData(ex, buf, offs, olen) =
  let len = olen - bilbyFsObjHeaderSize - 8
  in if len > olen then
    Error (eInval, ex)
  else
    let id = deserialise_le64(buf, offs)
    -- Ensure type of oid is ObjData
    in if ((id .&. binNot bilbyFsOidMaskAll) .|. bilbyFsOidMaskData) /= id then
        Error (eInval, ex)
      else
        deserialise_wordarray_U8(ex, buf, offs + 8, len)
        | Error (e, ex) -> Error (e, ex)
        | Success (ex, odata) ->
          let od:ObjData = #{id,odata}
          in Success (ex, od, offs + 8 + len)

freeObjData: (SysState, ObjData take (..)) -> SysState
freeObjData(ex, od) = ex

type ObjSuper = { nb_eb : U32
                , eb_size : U32
                , io_size : U32
                , nb_reserved_gc : U32
                , nb_reserved_del : U32
                , cur_eb : U32
                , cur_offs : U32
                , last_inum : U32
                , next_sqnum : U64
}
newObjSuper: SysState -> R (SysState, ObjSuper take(..)) SysState
freeObjSuper: (SysState, ObjSuper take (..)) -> SysState

mkObjSuper: (ObjSuper take(..), UbiVolInfo!, UbiDevInfo!) -> ObjSuper
mkObjSuper (sup, vol, dev) = sup {nb_eb=wubi_vol_size vol,
    eb_size=wubi_vol_usable_leb_size vol,
    io_size=wubi_dev_min_io_size dev, nb_reserved_gc=0, nb_reserved_del=0,
    cur_eb=0, cur_offs=0, last_inum=0, next_sqnum=0}

bilbyFsObjSuperSize : U32
bilbyFsObjSuperSize = 40

serialise_ObjSuper:(Buffer, BufOffs, ObjSuper!) -> (Buffer, BufOffs)
serialise_ObjSuper(buf, offs, os) =
  let buf = serialise_le32(buf, offs, os.nb_eb)
  and buf = serialise_le32(buf, offs+4, os.eb_size)
  and buf = serialise_le32(buf, offs+8, os.io_size)
  and buf = serialise_le32(buf, offs+12, os.nb_reserved_gc)
  and buf = serialise_le32(buf, offs+16, os.nb_reserved_del)
  and buf = serialise_le32(buf, offs+20, os.cur_eb)
  and buf = serialise_le32(buf, offs+24, os.cur_offs)
  and buf = serialise_le32(buf, offs+28, os.last_inum)
  and buf = serialise_le64(buf, offs+32, os.next_sqnum)
  in (buf, offs+bilbyFsObjSuperSize)

serialise_size_ObjSuper: ObjSuper! -> U32
serialise_size_ObjSuper _ = bilbyFsObjSuperSize

deserialise_ObjSuper: (SysState, Buffer!, BufOffs) -> R (SysState, ObjSuper, BufOffs) (ErrCode, SysState)
deserialise_ObjSuper(ex, buf, offs) =
  let Success (ex, sup) <= newObjSuper ex |> Error ex -> Error (eNoMem, ex)
  and nb_eb = deserialise_le32(buf, offs)
  and eb_size = deserialise_le32(buf, offs+4)
  and io_size = deserialise_le32(buf, offs+8)
  and nb_reserved_gc = deserialise_le32(buf, offs+12)
  and nb_reserved_del = deserialise_le32(buf, offs+16)
  and cur_eb = deserialise_le32(buf, offs+20)
  and cur_offs = deserialise_le32(buf, offs+24)
  and last_inum = deserialise_le32(buf, offs+28)
  and next_sqnum = deserialise_le64(buf, offs+32)
  and sup = sup {nb_eb, eb_size, io_size, nb_reserved_gc, nb_reserved_del, cur_eb, cur_offs, last_inum, next_sqnum}
  in Success (ex, sup, offs+bilbyFsObjSuperSize)

type ObjInodeFlags = U32

type ObjInode = {id : ObjId
           , size : U64
           , atime_sec : U64
           , ctime_sec : U64
           , mtime_sec : U64
           , nlink : U32
           , uid : U32
           , gid : U32
           , mode : U32
           , flags : ObjInodeFlags
           -- , pad : U64
}
newObjInode: SysState -> R (SysState, ObjInode take(..)) SysState
freeObjInode: (SysState, ObjInode take (..)) -> SysState

bilbyFsOidMaskInum : U64
bilbyFsOidMaskInum = upcast word32Max << 32

{-
 definition "PObjInode data offs ==
     ObjInode.make
       (((Ple64 data offs) & ~(bilbyFsOidMaskAll | u32_to_u64(Word32Max)) | bilbyFsOidMaskInode) (* id *)
       (Ple64 data (offs+8)) (* size *)
       (Ple64 data (offs+16)) (* atime *)
       (Ple64 data (offs+24)) (* ctime *)
       (Ple64 data (offs+32)) (* mtime *)
       (Ple32 data (offs+40)) (* nlink *)
       (Ple32 data (offs+44)) (* uid *)
       (Ple32 data (offs+48)) (* gid *)
       (Ple32 data (offs+52)) (* mode *)
       (Ple32 data (offs+56)) (* flags *)
       (* End 60 bytes *)"

serialise_ObjInode(buf,offs,oi) = (buf', offs')
 precondition:
   offs + 60 <= buf.bound
   oi.oid = (oid & ~(bilbyFsOidMaskAll | u32_to_u64(Word32Max))
 postcondition:
   oi = PObjInode buf'.data offs
-}

serialise_ObjInode:(Buffer, BufOffs, ObjInode!) -> (Buffer, BufOffs)
serialise_ObjInode(buf, offs, oi) =
  let buf = serialise_le64(buf, offs, oi.id)
  and buf = serialise_le64(buf, offs+8, oi.size)
  and buf = serialise_le64(buf, offs+16, oi.atime_sec)
  and buf = serialise_le64(buf, offs+24, oi.ctime_sec)
  and buf = serialise_le64(buf, offs+32, oi.mtime_sec)
  and buf = serialise_le32(buf, offs+40, oi.nlink)
  and buf = serialise_le32(buf, offs+44, oi.uid)
  and buf = serialise_le32(buf, offs+48, oi.gid)
  and buf = serialise_le32(buf, offs+52, oi.mode)
  in (serialise_le32(buf, offs+56, oi.flags), offs+60)

bilbyFsObjInode : U32
bilbyFsObjInode = 60

{-# cinline serialise_size_ObjInode #-}
serialise_size_ObjInode: ObjInode! -> U32
serialise_size_ObjInode _ = bilbyFsObjInode

{-# cinline binNot #-}
binNot: U64 -> U64
binNot w = word64Max .^. w


{-
 precondition:
  offs + 60 <= buf.bound
 postcondition:
 !!h. if isError r then
    r = Error (eInval, h)
  else
    r = Success (h, PObjInode buf.data offs, offs + 56)
-}
deserialise_ObjInode: (SysState, Buffer!, BufOffs) -> R (SysState, ObjInode, BufOffs) (ErrCode, SysState)
deserialise_ObjInode(ex, buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- Ensure type of oid is ObjInode and xinfo = 0
  in if (id  .&. binNot (bilbyFsOidMaskAll .|. (upcast word32Max)) .|. bilbyFsOidMaskInode) /= id then
      Error (eInval, ex)
  else
    let Success (ex, oi) <= newObjInode ex |> Error ex -> Error (eNoMem, ex)
    and size = deserialise_le64(buf, offs + 8)
    and atime_sec = deserialise_le64(buf, offs + 16)
    and ctime_sec = deserialise_le64(buf, offs + 24)
    and mtime_sec = deserialise_le64(buf, offs + 32)
    and nlink = deserialise_le32(buf, offs + 40)
    and uid = deserialise_le32(buf, offs + 44)
    and gid = deserialise_le32(buf, offs + 48)
    and mode = deserialise_le32(buf, offs + 52)
    and flags = deserialise_le32(buf, offs + 56)
    and oi = oi{id,size,atime_sec,ctime_sec,mtime_sec,nlink,uid,gid,mode,flags}
    in Success (ex, oi, offs + 60)

{-
  deserialise_u8
    precondition:
     wellformed_buf buf
     offs + 1 > offs
    postcondition:
      if offs >= buf.bound then
        Error eInval
      else Success (buf[offs], offs+1)
       
-}
{-# cinline deserialise_u8 #-}
deserialise_u8: (Buffer!, BufOffs) -> U8
deserialise_u8(buf, offs) =
  wordarray_get[U8] (buf.data, offs)

{-# cinline deserialise_le16 #-}
deserialise_le16: (Buffer!, BufOffs) -> U16
deserialise_le16(buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  in ((upcast b1 << 8) .|. upcast b0)

{-
  (* le32 is undefined if offs + 3 >= buf.bound *)
  definition "le32 data offs == (u8_to_u32(data[offs+3]) << 24) | (u8_to_u32(data[offs+2]) << 16) |
                (u8_to_u32(data[offs+1]) << 8) | u8_to_u32(data[offs])"

  deserialise_le32
    precondition:
     wellformed_buf buf
     offs + 4 > offs
    postcondition:
      le32(buf.data, offs)
-}
{-# cinline deserialise_le32 #-}
deserialise_le32: (Buffer!, BufOffs) -> U32
deserialise_le32 (buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  and b2 = wordarray_get[U8] (buf.data, offs + 2)
  and b3 = wordarray_get[U8] (buf.data, offs + 3)
  in ((upcast b3 << 24) .|. (upcast b2 << 16) .|.
      (upcast b1 << 8 ) .|.  upcast b0)

{-# cinline deserialise_le64 #-}
deserialise_le64: (Buffer!, BufOffs) -> U64
deserialise_le64(buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  and b2 = wordarray_get[U8] (buf.data, offs + 2)
  and b3 = wordarray_get[U8] (buf.data, offs + 3)
  and b4 = wordarray_get[U8] (buf.data, offs + 4)
  and b5 = wordarray_get[U8] (buf.data, offs + 5)
  and b6 = wordarray_get[U8] (buf.data, offs + 6)
  and b7 = wordarray_get[U8] (buf.data, offs + 7)
  in ((upcast b7 << 56) .|. (upcast b6 << 48) .|.
      (upcast b5 << 40) .|. (upcast b4 << 32) .|.
      (upcast b3 << 24) .|. (upcast b2 << 16) .|.
      (upcast b1 << 8 ) .|.  upcast b0)
-- similar to above

deserialise_Obj_crc: (SysState, Buffer!, BufOffs) -> R (SysState, Obj, BufOffs) (ErrCode, SysState)
deserialise_Obj_crc(ex, buf, offs) =
  deserialise_Obj(ex, buf, offs)
  | Error (err, ex) ->
    Error (err, ex)
  | Success (ex, obj, end_offs) ->
    -- assert (end_offs == offs + obj.len) !obj ;
    let crcsum = crc32_buf #{buf, frm = offs + 8, to = end_offs}
    and crc = obj.crc !obj
    and obj {offs=_} = obj
    and obj = obj {offs}
    and obj {ounion} = obj
    and _ = print_ObjHeader obj !obj
    and obj = obj {ounion} 
    in if crc == crcsum then
      Success (ex, obj, end_offs)
    else
      let ex = deep_freeObj(ex, obj)
      in Error (eInval, ex)

{-# cinline setu8 #-}
setu8:  #{elem: U8, acc: (), obsv: U8! } -> #{elem: U8, acc: () }
setu8 #{elem=_, acc, obsv=elem} = #{elem,acc}

{-# cinline serialise_u8 #-}
serialise_u8: (Buffer, BufOffs, U8) -> Buffer
serialise_u8(buf {bound,data}, offs, val) =
  let #{arr=data, acc=_} = wordarray_modify[U8,(),U8] #{arr=data, idx=offs, f=setu8, acc=(), obsv=val}
  in buf {bound,data}

{-# cinline serialise_size_u8 #-}
serialise_size_u8: U8 -> U32
serialise_size_u8 _ = 1

{-
 serialise_le32
    precondition:
     offs + 4 > offs
     offs + 4 <= buf.bound
     wellformed_buf buf
    postcondition:
     le32(buf.data, offs) = val
-}
{-# cinline serialise_le32 #-}
serialise_le32: (Buffer, BufOffs, U32) -> Buffer
serialise_le32(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u32_to_u8(val))
  and buf = serialise_u8(buf, offs+1, u32_to_u8(val >> 8))
  and buf = serialise_u8(buf, offs+2, u32_to_u8(val >> 16))
  in serialise_u8(buf, offs+3, u32_to_u8(val >> 24))

{-# cinline serialise_le16 #-}
serialise_le16: (Buffer, BufOffs, U16) -> Buffer
serialise_le16(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u16_to_u8(val))
  in serialise_u8(buf, offs+1, u16_to_u8(val >> 8))

{-# cinline serialise_size_le32 #-}
serialise_size_le32: U32 -> U32
serialise_size_le32 _ = 4

u64_to_u8: U64 -> U8

{-
     see serialise_le32
-}
{-# cinline serialise_le64 #-}
serialise_le64: (Buffer, BufOffs, U64) -> Buffer
serialise_le64(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u64_to_u8(val))
  and buf = serialise_u8(buf, offs+1, u64_to_u8(val >> 8))
  and buf = serialise_u8(buf, offs+2, u64_to_u8(val >> 16))
  and buf = serialise_u8(buf, offs+3, u64_to_u8(val >> 24))
  and buf = serialise_u8(buf, offs+4, u64_to_u8(val >> 32))
  and buf = serialise_u8(buf, offs+5, u64_to_u8(val >> 40))
  and buf = serialise_u8(buf, offs+6, u64_to_u8(val >> 48))
  in        serialise_u8(buf, offs+7, u64_to_u8(val >> 56))

{-# cinline serialise_size_le64 #-}
serialise_size_le64: U64 -> U32
serialise_size_le64 _ = 8

-- This function does not work with ounion.ObjPad and ounion.ObjData
{-# cinline serialise_size_Obj #-}
serialise_size_Obj: Obj! -> U32
serialise_size_Obj obj =
  bilbyFsObjHeaderSize + serialise_size_ObjUnion obj.ounion

-- This function cannot be used with an ObjPad
serialise_size_ObjUnion: ObjUnion! -> U32
serialise_size_ObjUnion ounion =
 ounion
 | TObjInode obj -> serialise_size_ObjInode obj
 | TObjData obj -> serialise_size_ObjData obj
 | TObjDentarr obj -> serialise_size_ObjDentarr obj
 | TObjDel obj -> serialise_size_ObjDel obj
 | TObjSuper obj -> serialise_size_ObjSuper obj
 | TObjSummary obj -> serialise_size_ObjSummary obj.nb_sum_entry
 | TObjPad obj -> 0

{-# cinline deep_freeObjInode #-}
deep_freeObjInode: (SysState, ObjInode) -> SysState
deep_freeObjInode(ex, v) = freeObjInode(ex, v)

{-# cinline deep_freeObjData #-}
deep_freeObjData: (SysState, ObjData) -> SysState
deep_freeObjData(ex, v) =
  let v {odata} = v
  and ex = wordarray_free[U8] (ex, odata) in
  freeObjData(ex, v)

{-# cinline deep_freeObjSuper #-}
deep_freeObjSuper: (SysState, ObjSuper) -> SysState
deep_freeObjSuper(ex, v) = freeObjSuper(ex, v)

serialise_Obj_crc: (Buffer, U32, Obj) -> (Buffer, U32, Obj)
serialise_Obj_crc (buf, offs, obj) =
  let (buf, offs') = serialise_Obj(buf, offs, obj) !obj
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf #{buf, frm=offs + 8, to=offs'} !buf
  and obj = obj {crc, offs}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (buf, offs', obj)

-- This is silly but we can't build a complete Obj
-- otherwise we can't guarantee that we will get
-- ObjSuper back
serialise_Obj_Super_crc: (SysState,Buffer, U32, Obj take (ounion), ObjSuper!) -> (SysState, Buffer, U32, Obj take (ounion))
serialise_Obj_Super_crc (ex,buf, offs, obj, sup) =
  let obj = obj {ounion = TObjPad ()}
  and (buf, offs') = serialise_ObjHeader(buf, offs, obj) !obj
  and obj {ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  and (buf, offs') = serialise_ObjSuper(buf, offs', sup)
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf#{buf, frm=offs + 8, to=offs'} !buf
  and obj = obj {crc}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (ex, buf, offs', obj)

